<<<<<<< HEAD
import {Buffer} from 'node:buffer';
import path from 'node:path';
import childProcess from 'node:child_process';
import process from 'node:process';
import crossSpawn from 'cross-spawn';
import stripFinalNewline from 'strip-final-newline';
import {npmRunPathEnv} from 'npm-run-path';
import onetime from 'onetime';
import {makeError} from './lib/error.js';
import {normalizeStdio, normalizeStdioNode} from './lib/stdio.js';
import {spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler} from './lib/kill.js';
import {handleInput, getSpawnedResult, makeAllStream, validateInputSync} from './lib/stream.js';
import {mergePromise, getSpawnedPromise} from './lib/promise.js';
import {joinCommand, parseCommand, getEscapedCommand} from './lib/command.js';
=======
'use strict';
const path = require('path');
const childProcess = require('child_process');
const crossSpawn = require('cross-spawn');
const stripFinalNewline = require('strip-final-newline');
const npmRunPath = require('npm-run-path');
const onetime = require('onetime');
const makeError = require('./lib/error');
const normalizeStdio = require('./lib/stdio');
const {spawnedKill, spawnedCancel, setupTimeout, setExitHandler} = require('./lib/kill');
const {handleInput, getSpawnedResult, makeAllStream, validateInputSync} = require('./lib/stream.js');
const {mergePromise, getSpawnedPromise} = require('./lib/promise.js');
const {joinCommand, parseCommand} = require('./lib/command.js');
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507

const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;

const getEnv = ({env: envOption, extendEnv, preferLocal, localDir, execPath}) => {
	const env = extendEnv ? {...process.env, ...envOption} : envOption;

	if (preferLocal) {
<<<<<<< HEAD
		return npmRunPathEnv({env, cwd: localDir, execPath});
=======
		return npmRunPath.env({env, cwd: localDir, execPath});
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	}

	return env;
};

<<<<<<< HEAD
const handleArguments = (file, args, options = {}) => {
=======
const handleArgs = (file, args, options = {}) => {
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	const parsed = crossSpawn._parse(file, args, options);
	file = parsed.command;
	args = parsed.args;
	options = parsed.options;

	options = {
		maxBuffer: DEFAULT_MAX_BUFFER,
		buffer: true,
		stripFinalNewline: true,
		extendEnv: true,
		preferLocal: false,
		localDir: options.cwd || process.cwd(),
		execPath: process.execPath,
		encoding: 'utf8',
		reject: true,
		cleanup: true,
		all: false,
		windowsHide: true,
<<<<<<< HEAD
		...options,
=======
		...options
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	};

	options.env = getEnv(options);

	options.stdio = normalizeStdio(options);

	if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {
		// #116
		args.unshift('/q');
	}

	return {file, args, options, parsed};
};

const handleOutput = (options, value, error) => {
	if (typeof value !== 'string' && !Buffer.isBuffer(value)) {
<<<<<<< HEAD
		// When `execaSync()` errors, we normalize it to '' to mimic `execa()`
=======
		// When `execa.sync()` errors, we normalize it to '' to mimic `execa()`
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		return error === undefined ? undefined : '';
	}

	if (options.stripFinalNewline) {
		return stripFinalNewline(value);
	}

	return value;
};

<<<<<<< HEAD
export function execa(file, args, options) {
	const parsed = handleArguments(file, args, options);
	const command = joinCommand(file, args);
	const escapedCommand = getEscapedCommand(file, args);

	validateTimeout(parsed.options);
=======
const execa = (file, args, options) => {
	const parsed = handleArgs(file, args, options);
	const command = joinCommand(file, args);
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		// Ensure the returned error is always both a promise and a child process
		const dummySpawned = new childProcess.ChildProcess();
		const errorPromise = Promise.reject(makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
<<<<<<< HEAD
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false,
=======
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		}));
		return mergePromise(dummySpawned, errorPromise);
	}

	const spawnedPromise = getSpawnedPromise(spawned);
	const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
	const processDone = setExitHandler(spawned, parsed.options, timedPromise);

	const context = {isCanceled: false};

	spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
	spawned.cancel = spawnedCancel.bind(null, spawned, context);

	const handlePromise = async () => {
		const [{error, exitCode, signal, timedOut}, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
		const stdout = handleOutput(parsed.options, stdoutResult);
		const stderr = handleOutput(parsed.options, stderrResult);
		const all = handleOutput(parsed.options, allResult);

		if (error || exitCode !== 0 || signal !== null) {
			const returnedError = makeError({
				error,
				exitCode,
				signal,
				stdout,
				stderr,
				all,
				command,
<<<<<<< HEAD
				escapedCommand,
				parsed,
				timedOut,
				isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
				killed: spawned.killed,
=======
				parsed,
				timedOut,
				isCanceled: context.isCanceled,
				killed: spawned.killed
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
			});

			if (!parsed.options.reject) {
				return returnedError;
			}

			throw returnedError;
		}

		return {
			command,
<<<<<<< HEAD
			escapedCommand,
=======
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
			exitCode: 0,
			stdout,
			stderr,
			all,
			failed: false,
			timedOut: false,
			isCanceled: false,
<<<<<<< HEAD
			killed: false,
		};
	};
=======
			killed: false
		};
	};

	const handlePromiseOnce = onetime(handlePromise);
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507

	const handlePromiseOnce = onetime(handlePromise);

	handleInput(spawned, parsed.options.input);

	spawned.all = makeAllStream(spawned, parsed.options);

	return mergePromise(spawned, handlePromiseOnce);
<<<<<<< HEAD
}

export function execaSync(file, args, options) {
	const parsed = handleArguments(file, args, options);
	const command = joinCommand(file, args);
	const escapedCommand = getEscapedCommand(file, args);

	validateInputSync(parsed.options);

=======
};

module.exports = execa;

module.exports.sync = (file, args, options) => {
	const parsed = handleArgs(file, args, options);
	const command = joinCommand(file, args);

	validateInputSync(parsed.options);

>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	let result;
	try {
		result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
	} catch (error) {
		throw makeError({
			error,
			stdout: '',
			stderr: '',
			all: '',
			command,
<<<<<<< HEAD
			escapedCommand,
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false,
=======
			parsed,
			timedOut: false,
			isCanceled: false,
			killed: false
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		});
	}

	const stdout = handleOutput(parsed.options, result.stdout, result.error);
	const stderr = handleOutput(parsed.options, result.stderr, result.error);

	if (result.error || result.status !== 0 || result.signal !== null) {
		const error = makeError({
			stdout,
			stderr,
			error: result.error,
			signal: result.signal,
			exitCode: result.status,
			command,
<<<<<<< HEAD
			escapedCommand,
			parsed,
			timedOut: result.error && result.error.code === 'ETIMEDOUT',
			isCanceled: false,
			killed: result.signal !== null,
=======
			parsed,
			timedOut: result.error && result.error.code === 'ETIMEDOUT',
			isCanceled: false,
			killed: result.signal !== null
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		});

		if (!parsed.options.reject) {
			return error;
		}

		throw error;
	}

	return {
		command,
<<<<<<< HEAD
		escapedCommand,
=======
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		exitCode: 0,
		stdout,
		stderr,
		failed: false,
		timedOut: false,
		isCanceled: false,
<<<<<<< HEAD
		killed: false,
=======
		killed: false
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	};
}

<<<<<<< HEAD
export function execaCommand(command, options) {
	const [file, ...args] = parseCommand(command);
	return execa(file, args, options);
}

export function execaCommandSync(command, options) {
	const [file, ...args] = parseCommand(command);
	return execaSync(file, args, options);
}

export function execaNode(scriptPath, args, options = {}) {
=======
module.exports.command = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa(file, args, options);
};

module.exports.commandSync = (command, options) => {
	const [file, ...args] = parseCommand(command);
	return execa.sync(file, args, options);
};

module.exports.node = (scriptPath, args, options = {}) => {
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
	if (args && !Array.isArray(args) && typeof args === 'object') {
		options = args;
		args = [];
	}

<<<<<<< HEAD
	const stdio = normalizeStdioNode(options);
	const defaultExecArgv = process.execArgv.filter(arg => !arg.startsWith('--inspect'));

	const {
		nodePath = process.execPath,
		nodeOptions = defaultExecArgv,
	} = options;
=======
	const stdio = normalizeStdio.node(options);

	const {nodePath = process.execPath, nodeOptions = process.execArgv} = options;
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507

	return execa(
		nodePath,
		[
			...nodeOptions,
			scriptPath,
<<<<<<< HEAD
			...(Array.isArray(args) ? args : []),
=======
			...(Array.isArray(args) ? args : [])
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
		],
		{
			...options,
			stdin: undefined,
			stdout: undefined,
			stderr: undefined,
			stdio,
<<<<<<< HEAD
			shell: false,
		},
	);
}
=======
			shell: false
		}
	);
};
>>>>>>> 5fb457ee39b1a3391e39c68ad7528024e273d507
